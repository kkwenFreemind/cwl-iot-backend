package community.waterlevel.iot.module.metric.model.entity;

import community.waterlevel.iot.common.annotation.DataPermission;
import community.waterlevel.iot.module.metric.model.enums.MetricDataType;
import community.waterlevel.iot.module.metric.model.enums.MetricUnit;
import community.waterlevel.iot.module.metric.model.enums.PhysicalQuantity;
import jakarta.persistence.*;
import jakarta.validation.constraints.AssertTrue;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;
import lombok.Getter;
import lombok.Setter;
import org.hibernate.annotations.SQLDelete;
import org.hibernate.annotations.SQLRestriction;

import java.time.LocalDateTime;

/**
 * JPA entity representing IoT metric definitions in the water level monitoring system.
 *
 * <p>This entity maps to the {@code iot_metric_definitions} table and defines
 * the structure and metadata for various IoT device metrics such as water level,
 * temperature, pressure, and other sensor measurements.
 *
 * <p>Key features:
 * <ul>
 *   <li>Department-scoped metric definitions with unique constraints</li>
 *   <li>Support for various data types (Int8, Int16, Int32, etc.)</li>
 *   <li>Physical quantity and unit specifications for proper data interpretation</li>
 *   <li>Soft delete functionality with {@code is_active} flag</li>
 *   <li>Version control for metric definition evolution</li>
 *   <li>Data permission filtering based on department access</li>
 * </ul>
 *
 * <p>Database table: {@code iot_metric_definitions}
 *
 * @author Chang Xiu-Wen, AI-Enhanced
 * @since 2025/09/16
 * @see community.waterlevel.iot.system.model.entity.SysDept
 */
@Getter
@Setter
@Entity
@Table(name = "iot_metric_definitions")
@SQLDelete(sql = "UPDATE iot_metric_definitions SET is_active = false WHERE id = ?")
@SQLRestriction("is_active = true")
@DataPermission(deptAlias = "imd", deptIdColumnName = "deptId", userAlias = "u", userIdColumnName = "createdBy")
public class IotMetricDefinition {

    /**
     * Primary key: Auto-generated unique identifier for the metric definition.
     *
     * <p>This ID is automatically generated by the database using a serial sequence
     * and serves as the unique identifier for each metric definition.
     *
     * <p>Database column: {@code id} (SERIAL, NOT NULL)
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    /**
     * Department identifier that owns this metric definition.
     *
     * <p>Links the metric definition to its managing department for organizational
     * hierarchy and access control. This field is used by the data permission
     * system to filter metrics based on user department access.
     *
     * <p>Database column: {@code dept_id} (BIGINT, NOT NULL)
     * <p>Foreign Key: References {@code sys_dept(id)} with CASCADE delete
     */
    @NotNull(message = "Department ID cannot be null")
    @Column(name = "dept_id", nullable = false)
    private Long deptId;

    /**
     * Human-readable name of the metric.
     *
     * <p>This field stores the descriptive name for the metric, such as
     * "Water Level", "Temperature", "Pressure", or "Flow Rate".
     * Must be unique within each department.
     *
     * <p>Database column: {@code metric_name} (TEXT, NOT NULL)
     * <p>Constraints: Unique within department (enforced by database)
     * <p>Validation: Not blank, maximum 255 characters
     */
    @NotBlank(message = "Metric name cannot be blank")
    @Size(max = 255, message = "Metric name cannot exceed 255 characters")
    @Column(name = "metric_name", nullable = false)
    private String metricName;

    /**
     * Optional alias or short name for the metric.
     *
     * <p>Provides an alternative shorter name for the metric that can be used
     * in displays, reports, or API responses where space is limited.
     *
     * <p>Database column: {@code alias} (TEXT, NULLABLE)
     * <p>Validation: Maximum 100 characters when provided
     */
    @Size(max = 100, message = "Metric alias cannot exceed 100 characters")
    @Column(name = "alias")
    private String alias;

    /**
     * Physical quantity being measured.
     *
     * <p>Describes the physical property being measured using predefined enum values.
     * This ensures type safety and consistency across the system.
     *
     * <p>Database column: {@code physical_quantity} (TEXT, NOT NULL)
     * <p>Validation: Not null
     */
    @NotNull(message = "Physical quantity cannot be null")
    @Enumerated(EnumType.STRING)
    @Column(name = "physical_quantity", nullable = false)
    private PhysicalQuantity physicalQuantity;

    /**
     * Unit of measurement for the metric.
     *
     * <p>Specifies the unit in which the metric values are expressed using predefined enum values.
     * This ensures consistency and prevents invalid unit assignments.
     *
     * <p>Database column: {@code unit} (TEXT, NOT NULL)
     * <p>Validation: Not null
     */
    @NotNull(message = "Unit cannot be null")
    @Enumerated(EnumType.STRING)
    @Column(name = "unit", nullable = false)
    private MetricUnit unit;

    /**
     * Data type of the metric values.
     *
     * <p>Defines the data type for storing metric values using Sparkplug B compatible enum values.
     * This ensures data type consistency and proper data handling.
     *
     * <p>Database column: {@code data_type} (TEXT, NOT NULL)
     * <p>Validation: Not null
     */
    @NotNull(message = "Data type cannot be null")
    @Enumerated(EnumType.STRING)
    @Column(name = "data_type", nullable = false)
    private MetricDataType dataType;

    /**
     * Active status of the metric definition.
     *
     * <p>Indicates whether this metric definition is currently active and available
     * for use. Inactive definitions are filtered out by the soft delete mechanism.
     *
     * <p>Database column: {@code is_active} (BOOLEAN, NOT NULL, DEFAULT true)
     */
    @NotNull(message = "Active status cannot be null")
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;

    /**
     * Version number for optimistic locking and change tracking.
     *
     * <p>Tracks the version of the metric definition for concurrent update control
     * and audit purposes. Automatically incremented on each update.
     *
     * <p>Database column: {@code version} (INTEGER, NOT NULL, DEFAULT 1)
     */
    @NotNull(message = "Version cannot be null")
    @Column(name = "version", nullable = false)
    private Integer version = 1;

    /**
     * Timestamp when the metric definition was created.
     *
     * <p>Automatically set to the current timestamp when the record is first created.
     * This field is managed by the database and should not be set manually.
     *
     * <p>Database column: {@code created_at} (TIMESTAMPTZ, NOT NULL, DEFAULT now())
     */
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    /**
     * Timestamp when the metric definition was last updated.
     *
     * <p>Automatically updated to the current timestamp whenever the record is modified.
     * This field is managed by the database and should not be set manually.
     *
     * <p>Database column: {@code updated_at} (TIMESTAMPTZ, NOT NULL, DEFAULT now())
     */
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    /**
     * Checks if this metric represents a numeric data type.
     *
     * @return true if the data type is numeric, false otherwise
     */
    public boolean isNumericType() {
        return dataType != null && dataType.isNumeric();
    }

    /**
     * Validates if the unit is compatible with the physical quantity.
     *
     * @return true if the unit is compatible with the physical quantity, false otherwise
     */
    @AssertTrue(message = "Unit must be compatible with physical quantity")
    public boolean isUnitCompatible() {
        return unit != null && physicalQuantity != null &&
               unit.isCompatibleWith(physicalQuantity);
    }
}